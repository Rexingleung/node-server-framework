# Nodejs服务层规划设计

<a name="2e2d5a8d"></a>
## 一、背景
当前我们所处的状态为前后端伪分离，即：<br />（1）前端负责开发页面，然后浏览器请求，CDN返回HTML页面；<br />（2）HTML中的JS代码以Ajax方式请求后台的Restful接口；<br />（3）接口返回Json数据，页面解析Json数据，通过Dom操作渲染页面；<br />结合的方式，其结构图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/138910/1572857170041-d3f9514f-77c6-4dfc-bbad-83c0a9ec1817.png#align=left&display=inline&height=167&name=image.png&originHeight=304&originWidth=580&size=32707&status=done&width=318)

这些步骤都由用户所使用的设备中逐步执行，也就是说用户的设备性能与APP的运行速度联系的更紧换句话说就是如果用户的设备很低端，那么APP打开页面的速度会越慢。

首先，这种方式的优点是很明显的。前端不会嵌入任何后台代码，前端专注于HTML、CSS、JS的开发，不依赖于后端。自己还能够模拟Json数据来渲染页面。发现Bug，也能迅速定位出是谁的问题。<br />然而，在这种架构下，还是存在明显的弊端的。最明显的有如下几点：<br />     1）JS存在大量冗余，在业务复杂的情况下，页面的渲染部分的代码，非常复杂；<br />     2）在Json返回的数据量比较大的情况下，渲染的十分缓慢，会出现页面卡顿的情况；<br />     3）资源消耗严重，在业务复杂的情况下，一个页面可能要发起多次HTTP请求才能将页面渲染完毕。在PC端场景下建立多次HTTP请求可能感觉不太明显。但是在移动端建立一次HTTP请求则需要消耗较多资源。<br />     正是因为如上缺点，我们才亟需真正的前后端分离架构。

<a name="3N3M0"></a>
## 二、目标
1）**适配性提升**；我们其实在开发过程中，经常会给PC端、app端各自研发一套前端。其实对于不同的端来说，大部分业务逻辑是一样的。唯一区别就是交互展现逻辑不同。如果controller层在后端手里，后端为了这些不同端页面展示逻辑，自己维护这些controller，模版无法重用，徒增和前端沟通端成本。 如果增加了node.js层，此时架构图如下：<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/138910/1572857520572-e8df3bfd-839b-43e3-a882-fe35a1a2d6f6.png#align=left&display=inline&height=132&name=image.png&originHeight=246&originWidth=617&size=47657&status=done&width=332)<br />在该结构下，每种前端的界面展示逻辑由node层自己维护。如果产品经理中途想要改动界面什么的，可以由前端自己专职维护，后端无需操心。前后端各司其职，后端专注自己的业务逻辑开发，前端专注产品效果开发。

2）**响应速度提升**；我们有时候，会遇到后端返回给前端的数据太简单了，前端需要对这些数据进行逻辑运算。那么在数据量比较小的时候，对其做运算分组等操作，并无影响。但是当数据量大的时候，会有明显的卡顿效果。这时候，node中间层其实可以将很多这样的代码放入node层处理、也可以替后端分担一些简单的逻辑、又可以用模板引擎自己掌握前台的输出。这样做灵活度、响应度都大大提升。

3）**性能得到提升**；大家应该都知道微服务划分有单一职责原则。从该角度来看，我们请求一个页面，可能要响应很多个后端接口，请求变多了，自然速度就变慢了，这种现象在移动端更加严重。再者。后端出于性能和别的原因，提供的接口所返回的数据格式也许不太适合前端直接使用，前端所需的排序功能、筛选功能，以及到了视图层的页面展现，也许都需要对接口所提供的数据进行二次处理。这些处理虽可以放在前端来进行，但也许数据量一大便会浪费浏览器性能。采用node作为中间层，将页面所需要的多个后端数据，直接在内网阶段就拼装好，再统一返回给前端，会得到更好的性能。

4）**提高开发效率**；用NodeJs来作为桥梁架接服务器端API输出的JSON，同时也可以接入mock数据工具进行数据模拟。在于后端接口还没有完成定义和开发时，NodeJs就可以通过mock数据工具进行接口数据给予前端人员完成数据对接，节约大量等待时间。

<a name="YOlSm"></a>
# 三、业务设计
<a name="2kffV"></a>
## 3.1 业务设计主要模块


## 3.2 业务设计说明

- node服务层会将后端返回的数据进行过滤和数据归档处理 , 做数据服务 , 根据不同的业务场景，生成不同的数据服务 , 可只专注于数据输出;
- 针对不同的业务模块 , node服务层 , 可以对不同的服务器进行数据请求 , 可对多服务进行拆解 ;
- 面向多变的前端功能需求 , 以及多人员开发的前端项目 , node服务层 , 可做到数据验证功能 , 保证node服务层与后台进行连接时数据的安全以及完整性 ;
- 由node服务层记录客户端行为 , 对每次的请求都做日志记录 , 且记录下每个traceId , 确定每个请求对应的每一条日志 ;
- 根据前端业务横向更加 , 可对node服务层进行更量处理 ;

<a name="4iTPT"></a>
# 四 技术设计
<a name="GkjY7"></a>
## 4.1 设计原则
<a name="iGqtD"></a>
### 4.1.1 项目规范统一原则
<a name="fsWiz"></a>
#### 4.1.1.1 项目结构约束

  - 结构如下<br />
![](https://raw.githubusercontent.com/Rexingleung/test-ci/master/egg%E7%BB%93%E6%9E%84.png#align=left&display=inline&height=2781&originHeight=2781&originWidth=2293&status=done&width=2293)
<a name="N4gZl"></a>
#### 4.1.1.2 开发流程约束

  - 路由模块, 必须写在app/router/* 下面, 然后在app/router.js里面集中实例出来
  - 主要的业务逻辑代码写在 app/controller/* 下
  - 拓展的api, 请求模块, 写在extend下的application.js里面的http.js
  - 前期复用性较高的代码, 直接放在lib/plugin目录下, 直接使用
  - 当该插件长期稳定后, 可单独拿出来做为node_module进行引用, 作为一个单独的插件
  - 某些插件针对处理某个业务场景, 这时为了其更高的复用性, 可抽离为独立的 framework 进行发布。

<a name="62HRz"></a>
#### 4.1.1.3 测试规范约束

  - 不管是业务代码还是插件 / 抽离出来的框架都需要写单元测试代码, 保证在正式环境中正常运行
  - 单元测试代码写在test/* , test的目录结构保持跟app的目录结构一致
  - 上线前, 需本地的npm run test运行正常
<a name="8ZdeN"></a>
#### 4.1.1.4 日志记录规范

  - 日志的线上文件结构如下<br />
  - 代码规范如下, 其中traceId为请求头的X-request-ID, 该请求头是在nginx请求转发的时候设置的, 这个是为了确定每一条日志都是可追溯的```javascript
日志时间[]traceId[]服务端IP[]客户端IP[]日志级别[]日志内容
```

  - 在容错代码逻辑中, 统一错误日志，所有 logger 中使用 .error() 打印的 ERROR 级别日志都会打印到统一的错误日志文件中，为了保证异常可追踪，必须保证所有抛出的异常都是 Error 类型，因为只有 Error 类型才会带上堆栈信息，定位到问题```javascript
ctx.logger.error(new Error('whoops'));
```

  - 插件级别和框架级别的日志使用app.coreLogger```javascript
module.exports = app => {
        app.coreLogger.info();
    };
```

  - 日志每30天会进行一次清理

<a name="cpr1W"></a>
### 4.1.2 服务的无状态性原则

- <a name="f73ea97a"></a>
##### node服务层体系的基本要求是服务无状态。无状态的服务是可伸缩、高可用性的基础。

  - 即抽离的插件, 下层的框架文件必须是无状态的
  - 自定义的加载单元也是要基于app对象进行开发

<a name="i8YZT"></a>
### 4.1.3 服务调度可控原则

- <a name="ab67db8d"></a>
##### 业务逻辑的超时时间

  - 所有的业务逻辑必须添加超时时间, 超时时间默认设置60s, 超过60秒, 需返回一定的状态码和业务内容并同时记录日志

<a name="PY4sk"></a>
### 4.1.4 服务划分
监控服务（MonitorServer）<br />数据获取（Data Request）<br />请求拆分（Interface Split）<br />日志服务（LogServer）<br />Nginx<br />![image.png](https://cdn.nlark.com/yuque/0/2019/png/138910/1573790173199-16929767-b80e-4e4c-b091-ec415affc746.png#align=left&display=inline&height=173&name=image.png&originHeight=258&originWidth=446&size=15445&status=done&width=299)

<a name="iDZLf"></a>
## 4.2 总体架构

![image.png](https://cdn.nlark.com/yuque/0/2019/png/138910/1574228501899-b7e82a72-e873-4672-9c78-32c6d865a1fa.png#align=left&display=inline&height=645&name=image.png&originHeight=918&originWidth=927&size=86836&status=done&width=651)
<a name="fmRlO"></a>
### 4.2.1 详细设计
<a name="W397k"></a>
#### 4.2.1.1 技术框架

  - egg(底层框架)
  - egg-script(加强项目运行健壮性)
  - egg-cors(处理跨域框架)
  - nginx(反向代理, 接口转发)
  - axios(数据请求)
  - eslint(代码检测)
<a name="qQzI4"></a>
#### 4.2.1.2 请求拆分设计
对于目前出现的各种请求 , node和浏览器之间 , 只做post请求 , 前端对于一定业务的页面 , 保证发起一个请求 , 符合该页面的数据返回 , 由于https请求比http请求多一层ssl协议 , 意味着就多一层握手机制 , 以及https基于http1.1带着巨大的http头部信息在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费 , 所以在一定情况下 , 需要在https和http1.1的情况下减少tcp连接数和请求数 <br />在node端对浏览器发来的请求 , 根据头部信息和路由信息 , 对路由进行拆分 , 再请求后端数据 , 对于这一层所消耗的请求时长 , 可在业务逻辑数据重组中互补
<a name="15KuL"></a>
#### 4.2.1.3 日志设计
日志系统 , 记录四个方面 

  - 用户的行为操作
    - 即浏览器每个请求进来时的body信息 , 考虑到浏览器过来的请求 , 头部可能会携带的信息可能会有多达几百字节甚至上千字节，但Body却经常只有几十字节 , 所以头部信息不作日记记录 , 但除了一个特定的头部信息 , 即追踪日志的头部信息 , 可协商一个X-Http-RequestID作为日志id
  - node请求后台时拆分后的路由
    - 对于node拆分后的路由 , 日志系统需要做一次记录 , 主要记录的是body信息 , 以及X-Http-RequestID日志id , 同时这里需要跟后台协商 , 我们需要发送一个特定的ID作为每个请求的traceID , 后台返回时一并返回 , 保证node发送和接收的日志可形成链
  - 数据返回的信息
    - 返回的信息除了上述所说的traceID , 还有body信息
  - node项目的运行日志
    - 包括重启 , 停止 尽量记录每次重启和停止的发生的原因
<a name="feKis"></a>
#### 4.2.1.4 数据获取与重组设计
根据前端所需业务 , 将业务代码组装成前端所需代码 , 前端的业务逻辑迁移至node端 , 保证浏览器只运行不做任何逻辑代码
<a name="oPl5T"></a>
#### 4.2.1.5 监控设计
主要监控三个方面

  - 接口情况
    - node请求至后端40x情况 , 50x情况 , 在对于不同状态码段的http请求 , 在egg中间件做拦截 , 一旦发现node请求情况发生网络错误时 , 可做特定状态码返回 , 保证node和浏览器端通信正常
    - node请求的数据完整性问题 , 参考市平台的解决方案 , 使用https可以基本保证数据完整性的问题
  - node运行所占的cpu情况
    - 使用node自带的os模块读取系统每个node项目cpu情况 , 以及其占比
  - node运行的所占的内存情况
    - 使用node自带的os模块读取系统每个node项目内存情况 , 以及其占比
  - node重启监控 
    - 对于node重启的监控 , 可以使用pm2做监控
<a name="99f5da6b"></a>
#### 4.2.1.6 nginx设计

- 对于node中间层的服务 , 在node服务层上nginx所做的是

1. 负载均衡

    - (1) 对于node中间层选用加权轮询进行负载均衡
      - a. 对于多服务部署的负载均衡可以使用upstream 模块对每个server进行权重分配以及down处理 , 在.conf文件中 , 我们可以写到nginx.conf里面(如果只有一个web集群)，如果有多个web集群,最好写到vhosts里面,以虚拟主机的方式,这里写到nginx.conf里面

例子: 以IP地址1 比 IP地址2为1:2分配, 注意该分配用于后端服务器性能均衡的情况下 , 当后端服务器性能不均的情况下 , 权重应设置一样 , 这里的设置是当 IP地址1down掉时,  IP地址2自动分配

  - 2. 接口反向代理
    - (1) 为方便后期可能出现内网走数据的情况node中间层使用stream模块实现后端接口转发代理
<a name="UgIDA"></a>
#### 4.2.1.7 扩展设计
在每个node服务中 , 使用egg框架的扩展模块和插件模块进行无状态开发拓展 , 防止前端业务突然新增一个模块的情况<br />

<a name="8W32R"></a>
#### 4.2.1.8 加密设计

| 类型 | 方式 |
| --- | --- |
| 前端加密 | HTTPS |



<a name="xOwFv"></a>
#### 4.2.1.9 接口规范设计
**1）接口命名**<br />服务.资源.动作<br />举例：https://127.0.0.1/服务名/域/接口名/动作<br />**2）动作规范**

| **动作** | **http方法** | **备注** |
| --- | --- | --- |
| get | GET | 单个资源获取 |
| list | GET | 批量获取 |
| search | POST | 带有搜索条件 |
| count | POST | 根据搜索条件获取数量 |
| add | POST | 新增资源 |
| update | POST | 更新资源 |
| delete | POST | 删除资源 |


注意：POST请求禁止在URL添加任何参数！

<a name="83SPn"></a>
#### 4.2.1.10 接口数据接收类型
| **Http方法** | **方式** | **说明** |
| --- | --- | --- |
| POST | Request Payload | 常规post请求方式 |
|  | Form-data | 文件传输使用请求方式 |
| GET | URL承载 | 简单的资源获取请求方式 |

<a name="03Zzi"></a>
#### 4.2.1.11 接口请求添加头部

| **头部参数** | **适用http请求方法** | **说明** |
| --- | --- | --- |
| Authorization | POST，GET | token |
| poit_cloud_org |  | 企业id |
| poit_cloud_src_client |  | 平台标识 |
| X_Request_Id |  | 请求id（毫秒级时间戳） |

<a name="aVaKC"></a>
#### 
<a name="GcI73"></a>
#### 4.2.1.12 接口错误码设计
**1）HTTPCODE**<br />参考httpcode标准规范

**2）业务code**

| **业务CODE** | **内容** |
| --- | --- |
| 200 | 正常 |
| 400 | 请求错误 |


<a name="zjbiI"></a>
#### 4.2.1.13 **网关限流**
单个接口TPS 3000

<a name="PUTQw"></a>
# 五、业务分层演进计划
<a name="wCAy9"></a>
## 5.1 环境搭建
<a name="vuHhQ"></a>
### 5.1.1 目标
在服务器上搭建服务环境，整体环境搭建遵循《**前端Node Server服务部署配置设计**》文档设计及要求搭建，实现多服务环境配置统一化，便捷搭建便捷维护。

<a name="9y1Sa"></a>
## 5.2 服务构建
<a name="30XC0"></a>
### 5.2.1 目标
环境搭建完成后，按《**前端Node Server服务部署配置设计**》文档的服务设计部分，进行NodeServer整体功能及内部细分服务构建。<br />整体框架服务无业务逻辑，预留定向插件接口，如遇特殊要求则以定向插件形式进行接入使用，不对整体框架做改变。

<a name="AvRl8"></a>
## 5.3 服务对接
<a name="5S3tI"></a>
### 5.3.1 目标
web项目的请求指向由通过Ajax直接与后端通信切换为Ajax与NodeServer通信，web发起请求所需的数据将会由Node Server与后端做数据获取后，再组装返回给到web。<br />遵循一个项目对应一个NodeServer原则，如一个web项目需要接入多个NodeServer时，则可以通过Nginx网关将请求转发至不同NodeServer。


